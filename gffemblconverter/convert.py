#!/usr/bin/env python3
"""
EMBL writer for ENA data submission, based on the documentation at
ftp://ftp.ebi.ac.uk/pub/databases/embl/doc/usrman.txt.
The current version features limited threading support and has multiple
improvements compared to the original version.

GFF convertion is based on specifications from:
https://github.com/The-Sequence-Ontology/Specifications/blob/master/gff3.md
"""

import sys
import time
import gzip
import logging
from concurrent.futures import ThreadPoolExecutor
from Bio import SeqIO
from BCBio import GFF

from gffemblconverter.feature_table.embl_writer import EmblWriter
from gffemblconverter.concise_log import ConciseStreamHandler

SHAMELESS_PLUG = """
###############################################################################
# NBIS 2018 - Sweden                                                          #
# Authors: Martin Norling, Niclas Jareborg, Jacques Dainat                    #
# Please visit https://github.com/NBISweden/EMBLmyGFF3 for more information.  #
###############################################################################

"""

def gff_input(args):
    """Convenience functions that opens the files supplied in the args
    structure in the appropriate way and returns them so that they can be
    supplied directly to a FeatureTable.
    """
    if args.gff_file.endswith(".gz"):
        infile = gzip.open(args.gff_file)
    else:
        infile = open(args.gff_file)

    if args.fasta.endswith(".gz"):
        infasta = gzip.open(args.fasta)
    else:
        infasta = open(args.fasta)

    seq_dict = SeqIO.to_dict(SeqIO.parse(infasta, "fasta"))

    return {"gff_files":infile, "base_dict":seq_dict}

def resolve_output(args):
    """Convenience function that returns either stdout or a file handle with
    the correct extension, depending on wheather it should be gzip'ed or not.
    """
    if not args.output:
        return sys.stdout

    outfile = args.output
    if args.gzip:
        if not outfile.endswith(".embl.gz"):
            outfile += ".gz" if outfile.endswith(".embl") else ".embl.gz"
        return gzip.open(outfile, "wb")
    if not outfile.endswith(".embl"):
        outfile += ".embl"
    return open(outfile, "wb")

def start_logging(log_level):
    """Convenience function to set logging how we want if.
    """
    logger = logging.getLogger()
    handler = ConciseStreamHandler()
    formatter = logging.Formatter(("%(asctime)s %(levelname)s %(module)s: "
                                   "%(message)s"))
    handler.setFormatter(formatter)
    logger.setLevel(log_level)
    logger.addHandler(handler)

def convert(args):
    """
    This is the conversion function. It takes a command-line-arguments from
    argparse and starts the logging, reads the input data, and then starts
    converting to EMBL.
    """

    start_logging(50-10*(args.verbose-args.quiet))

    records = []

    if not args.shame:
        print(SHAMELESS_PLUG)

    thread_pool = None
    if args.num_threads > 1:
        thread_pool = ThreadPoolExecutor(max_workers=args.num_threads)

    logging.info("Starting record parsing")
    for record in GFF.parse(**gff_input(args)):
        records += [EmblWriter(record, thread_pool=thread_pool, header=args)]

    outfile = resolve_output(args)

    locus_tag_counter = 1
    for record in records:
        while record.get_progress() < 1.0:
            time.sleep(0.1)
        locus_tag_counter = record.update_locus_tags(locus_tag_counter)
        data = str(record) + "\n"
        if args.output:
            data = data.encode('utf8')
        outfile.write(data)

def main():
    """
    Main function when running as a command line tool. This function reads
    command-line arguments and passes them to convert().
    """

    import argparse

    parser = argparse.ArgumentParser(description=__doc__)

    # Positional arguments
    parser.add_argument("gff_file", help="Input gff-file.")
    parser.add_argument("fasta", help="Input fasta sequence.")

    # Feature table header information
    header = parser.add_argument_group("header information")

    header.add_argument("--accession",
                        default="XXX",
                        help=("Accession number(s) for the entry. This value "
                              "is automatically generated by ENA during the "
                              "submission process."))

    header.add_argument("--classification",
                        help=("Organism classification e.g 'Eukaryota; "
                              "Opisthokonta; Metazoa;'. If not set, will be "
                              "retrieved online on the NCBI taxonomy DB based "
                              "on the species name or taxid."))

    header.add_argument("--created",
                        help=("Creation time of the original entry, formatted "
                              "as: 'YYYY-MM-DD' or 'DD-MON-YYYY'."))

    header.add_argument("--data_class",
                        default="XXX",
                        help="Data class of the sample.",
                        choices=["CON", "PAT", "EST", "GSS", "HTC", "HTG",
                                 "MGA", "WGS", "TSA", "STS", "STD"])

    header.add_argument("--description",
                        default=["XXX"],
                        nargs="+",
                        help="Short description of the data.")

    header.add_argument("--keywords",
                        default=[],
                        nargs="+",
                        help="Keywords for the entry.")

    header.add_argument("--locus_tag",
                        help=("Locus tag prefix used to set the locus_tag "
                              "qualifier. The locus tag has to be registered "
                              "at ENA prior to submission"))

    header.add_argument("--molecule_type",
                        help="Molecule type of the sample.",
                        choices=["genomic DNA", "genomic RNA", "mRNA", "tRNA",
                                 "rRNA", "other RNA", "other DNA",
                                 "transcribed RNA", "viral cRNA",
                                 "unassigned DNA", "unassigned RNA"])

    header.add_argument("--organelle",
                        help=("Sample organelle, ex. 'Mitochondrion', 'Plasmid "
                              "pBR322', or 'Plastid:Chloroplast'."))

    header.add_argument("--project_id",
                        default="XXX",
                        help=("The International Nucleotide Sequence Database "
                              "Collaboration (INSDC) Project Identifier that "
                              "has been assigned to the entry."))

    header.add_argument("--reference_comment",
                        default=None,
                        help="Reference Comment.")

    header.add_argument("--reference_group",
                        default="XXX",
                        help=("Reference Group, the working groups/consortia "
                              "that produced the record."))

    header.add_argument("--reference_xref",
                        default=None,
                        help="Reference cross-reference.")

    header.add_argument("--reference_author", "--author",
                        nargs="+",
                        default="",
                        help="Author for the reference.")

    header.add_argument("--reference_title",
                        help="Reference Title.")

    header.add_argument("--reference_publisher",
                        default=None,
                        help="Reference publishing location.")

    header.add_argument("--reference_position",
                        nargs="+",
                        default=[],
                        help="Sequence position described by the reference.")

    header.add_argument("--species",
                        help=("Submission species, formatted as 'Genus"
                              " species' or using a taxid."))

    header.add_argument("--taxonomy",
                        help="Source taxonomy.",
                        default="XXX",
                        choices=["PHG", "ENV", "FUN", "HUM", "INV", "MAM",
                                 "VRT", "MUS", "PLN", "PRO", "ROD", "SYN",
                                 "TGN", "UNC", "VRL"])

    header.add_argument("--topology",
                        help="Sequence topology.",
                        choices=["linear", "circular"])

    header.add_argument("--translation_table",
                        type=int,
                        help="Translation table for the submission DNA.",
                        choices=list(range(1, 26)))

    header.add_argument("--version",
                        type=int,
                        default=1,
                        help="Submission version number.")


    # Logging arguments
    log = parser.add_argument_group("logging control")
    log.add_argument("-v", "--verbose",
                     action="count",
                     default=2,
                     help="Increase logging verbosity.")
    log.add_argument("-q", "--quiet",
                     action="count",
                     default=0,
                     help="Decrease logging verbosity.")

    # Script behaviour arguments
    parser.add_argument("--shame",
                        action="store_true",
                        help="Suppress the shameless plug.")

    parser.add_argument("-t", "--num_threads",
                        type=int, default=1,
                        help="Number of threads to use for conversion")

    parser.add_argument("-o", "--output",
                        help="Output filename, default is stdout.")

    parser.add_argument("-z", "--gzip",
                        action="store_true",
                        help="Gzip output file")

    args = parser.parse_args()

    convert(args)
